<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.18.0/prism.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.18.0/themes/prism.min.css">
  <link rel="stylesheet" href="index.css">
  <title>Ring Menu</title>
</head>

<body>
  {% macro example(code) %}
  <article class="example">
    <pre class="example__code"><code class="language-javascript">{{ code }}</code></pre>
    <section class="example__result"></section>
  </article>
  {% endmacro %}

  {% macro heading(type, title) %}
    <{{type}} id="{{title | joinStr}}">
      <a class="permalink" href="#{{title | joinStr}}">#</a> {{ title }}
    </{{type}}>
  {% endmacro %}

  <section class="examples">
    {{ heading('h1', 'Hello and hi') }}

    {{ heading('h2', 'The anatomy of a ring menu') }}
    
    {{ heading('h3', 'Circles') }}

    <p>Menus are assembled from the inside out. Let's take a look at the simplest menu possible; a menu that only contains one <em>circle</em>.</p>

    {{ example('
      const menu = RM.menu([
        RM.circle(50, "Circle", {fill: "red"}),
      ]);
      const svg = RM.build(menu);
    ') }}

    <p>Circles are optional and can only be found in the very center of a menu.</p>

    {{ heading('h3', 'Rings and sectors') }}

    <p>Menus are mostly made out of <em>rings</em>. A <em>ring</em> is a collection of <em>sectors</em> which are all on the same distance from the center of the menu. A <em>sector</em> is an SVG <code>&lt;path&gt;</code> element. Sectors are rendered clockwise in the order they're provided to the ring.</p>

    {{ example('
      const menu = RM.menu([
        RM.circle(50, "Circle", {fill: "red"}),
        RM.ring(100, [
          RM.sector("Sector 1", {fill: "lightblue"}),
          RM.sector("Sector 2", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Here we specified a ring with a width of 100 pixels that consists of two sectors. Notice how we didn't need to specify the size of our sectors; they split the ring into equal parts by themselves. What if we wanted our ring to have six sectors instead? Also, we've already mentioned that circles are optional, so how about a menu without a circle? Let's give it a try:</p>

    {{ example('
      const menu = RM.menu([
        RM.ring(150, [
          RM.sector("Sector 1", {fill: "lightblue"}),
          RM.sector("Sector 2", {fill: "lightgreen"}),
          RM.sector("Sector 3", {fill: "lightblue"}),
          RM.sector("Sector 4", {fill: "lightgreen"}),
          RM.sector("Sector 5", {fill: "lightblue"}),
          RM.sector("Sector 6", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>As you might have expected, the six sectors will divide the ring equally. Also, because menus are always built from the inside out and we didn't use a circle in this menu, it means that the ring will start from the very center of the menu, resulting in a menu that looks kind of like a pie chart.</p>

    <p>The great thing about rings is that a menu can have as many of them as you want, and they are all independent one from another. Let's say we wanted a menu that has one ring with three sectors inside, with another ring with two sectors around the first ring. We can construct that menu like so:</p>

    {{ example('
      const menu = RM.menu([
        RM.ring(100, [
          RM.sector("Inner 1", {fill: "lightblue"}),
          RM.sector("Inner 2", {fill: "lightgreen"}),
          RM.sector("Inner 3", {fill: "lightsalmon"}),
        ]),
        RM.ring(100, [
          RM.sector("Outer 1", {fill: "lightpink"}),
          RM.sector("Outer 2", {fill: "yellowgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    {{ heading('h3', 'Gaps') }}

    <p>What if we wanted to include some space between the two rings in the previous example? We can do that by using a <em>gap</em>. A <em>gap</em> is simply a ring of empty space. A menu can have an arbitrary amount of gaps.</p>

    {{ example('
        const menu = RM.menu([
          RM.gap(40),
          RM.ring(100, [
            RM.sector("Inner 1", {fill: "lightblue"}),
            RM.sector("Inner 2", {fill: "lightgreen"}),
            RM.sector("Inner 3", {fill: "lightsalmon"}),
          ]),
          RM.gap(50),
          RM.ring(100, [
            RM.sector("Outer 1", {fill: "lightpink"}),
            RM.sector("Outer 2", {fill: "yellowgreen"}),
          ]),
        ]);
        const svg = RM.build(menu);
      ')}}

    <p>Here we've added a 50 pixel wide gap between the two rings. Notice how we've also added a 40 pixel wide gap before the first ring. If you don't need a <em>circle</em> in the center of your menu, but you also don't want your first ring to start from the center, then use a <em>gap</em>.</p>

    {{ heading('h2', 'Controlling sector size') }}

    {{ heading('h3', 'Static angles') }}

    <p>While having sectors divide the ring equally by default might be useful in some cases, sometimes you'll want to specify the angle of each sector yourself. You can do that like so:</p>

    {{ example('
      const menu = RM.menu([
        RM.gap(40),
        RM.ring(100, [
          RM.sector("30", 30, {fill: "lightblue"}),
          RM.sector("40", 40, {fill: "lightgreen"}),
          RM.sector("50", 50, {fill: "lightsalmon"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Here we've constructed sectors of angles of 30, 40 and 50 degrees. The sum of the sector angles doesn't have to be equal to 360 degrees for them to render, but it must not be larger than 360.</p>

    {{ heading('h3', 'Static offsets') }}

    <p>What if we wanted to have empty space between sectors? We can do by specifying an offset on a sector:</p>

    {{ example('
      const menu = RM.menu([
        RM.gap(40),
        RM.ring(100, [
          RM.sector("1", 30, 20, {fill: "lightblue"}),
          RM.sector("2", 40, 50, {fill: "lightgreen"}),
          RM.sector("3", 50, {fill: "lightsalmon"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>In this example we have two offsets, one of 20 degrees and the other one of 50 degrees; resulting in a 20 degree gap between sectors 1 and 2, as well as a 50 degree gap between sectors 2 and 3.</p>

    <p>Optionally, we can set a <em>separator</em> on the ring. If a sector doesn't have its offset specified, it will use the <em>separator</em> of its parent ring (which defaults to zero if unspecified).</p>

    {{ example('
      const menu = RM.menu([
        RM.gap(40),
        RM.ring(100, 20, [
          RM.sector("1", 30, {fill: "lightblue"}),
          RM.sector("2", 40, 100, {fill: "lightgreen"}),
          RM.sector("3", 50, {fill: "lightsalmon"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Here, the offsets of sectors 1 and 3 are unspecified, so they inherit the ring's separator of 20 degrees, while sector 2 uses its own offset of 100 degrees.</p>

    <p>If we want to offset the entire ring by some amount, we can define the offset of the ring right after the separator.</p>

    {{ example('
      const menu = RM.menu([
        RM.ring(100, 0, 45, [
          RM.sector("1",{fill: "lightblue"}),
          RM.sector("2", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    {{ heading('h2', 'Dynamic values') }}

    {{ heading('h3', 'Dynamic angles and offsets') }}

    <p>Instead of supplying an angle or an offset as a static value, <code>RingMenu</code> also has the concept of <em>dynamic values</em>. A <em>dynamic value</em> has a <em>factor</em> and represents a part of the whole. The higher the factor of a dynamic value, the bigger part of the whole that particular dynamic value will take. Let's take a look at an example:</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.ring(100, [
          RM.sector("Sector 1", d(1), {fill: "lightblue"}),
          RM.sector("Sector 2", d(1), {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>The resulting ring might look familiar; in the beginning of this page, we created a ring with sectors that didn't have defined angles:</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.ring(100, [
          RM.sector("Sector 1", {fill: "lightblue"}),
          RM.sector("Sector 2", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>If you don't specify the angle of a sector, it will default to a dynamic value of factor 1. If all sectors in a ring have the same dynamic factor, they will all have equal angles.</p>

    <p>What if we wanted one sector to be twice as large as the other? To do that, we could calculate their angles manually and set them as static values. An easier way would be to make use of dynamic values.</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.ring(100, [
          RM.sector("Sector 1", d(2), {fill: "lightblue"}),
          RM.sector("Sector 2", d(1), {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Sector offsets can be dynamic as well.</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.ring(150, [
          RM.sector("Sector 1", d(2), d(1), {fill: "lightblue"}),
          RM.sector("Sector 2", d(1), d(2), {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Sector 1 is twice as big as sector 2, while the space from sector 1 to sector 2 is twice as small as the space from sector 2 to sector 1. Sectors or offsets of the same dynamic factor will have the same angle.</p>

    <p>A ring offset can also be a dynamic value.</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.ring(150, 0, d(0.5), [
          RM.sector("Sector 1", {fill: "lightblue"}),
          RM.sector("Sector 2", {fill: "lightgreen"}),
          RM.sector("Sector 3", {fill: "lightblue"}),
          RM.sector("Sector 4", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    {{ heading('h2', 'Mixing dynamic and static values') }}

    <p>Let's say you wanted a ring of sectors with fixed angles, but you also wanted to make sure that the space between each sector is equal. It's easy with dynamic values:</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.gap(50),
        RM.ring(100, d(1), [
          RM.sector("40", 40, {fill: "lightblue"}),
          RM.sector("80", 80, {fill: "lightgreen"}),
          RM.sector("20", 20, {fill: "lightblue"}),
          RM.sector("100", 100, {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>Remember that dynamic values represent parts of a whole. This whole is the entire 360 degrees minus any static angles or offsets your sector might have. If you were to calculate the offsets manually, you'd first have to calculate the whole and divide it by the number of sectors. Using dynamic values does all of that for you under the hood.</p>

    <p>We could just as easily do the opposite; make a ring where the offsets between sectors are static,while the sectors themselves are dynamic:</p>

    {{ example('
      const d = RM.dynamic;

      const menu = RM.menu([
        RM.gap(50),
        RM.ring(100, 30, [
          RM.sector("1", {fill: "lightblue"}),
          RM.sector("2", {fill: "lightgreen"}),
          RM.sector("3", d(2), {fill: "lightblue"}),
          RM.sector("4", {fill: "lightgreen"}),
        ]),
      ]);
      const svg = RM.build(menu);
    ')}}

    <p>We've ensured that the space between each sector is exactly 30 degrees, while also making sector 3 twice as large as the others.</p>


  </section>
  <script src="../dist/ring-menu.js"></script>
  <script src="index.js"></script>
</body>

</html>