{% set page = 'dynamic-values.html' %}
{% set title = 'Dynamic values | RingMenu' %}
{% set description = 'Explaining the concept of dynamic values which allow you to define menu parts of self-adjusting sizes.' %}
{% extends '_base.njk' %}

{% block page %}
  {{ heading('h1', 'Dynamic values') }}

  {{ heading('h2', 'Dynamic angles and offsets') }}

  <p>Instead of supplying an angle or an offset as a static value, <code>RingMenu</code> also has the concept of <em>dynamic values</em>. A <em>dynamic value</em> has a <em>factor</em> and represents a part of the whole. The higher the factor of a dynamic value, the bigger part of the whole that particular dynamic value will take. Let's take a look at an example:</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(100, [
        RM.sector("Sector 1", d(1), {fill: "lightblue"}),
        RM.sector("Sector 2", d(1), {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>The resulting ring might look familiar; in the beginning of this page, we created a ring with sectors that didn't have defined angles:</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(100, [
        RM.sector("Sector 1", {fill: "lightblue"}),
        RM.sector("Sector 2", {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>If you don't specify the angle of a sector, it will default to a dynamic value of factor 1. If all sectors in a ring have the same dynamic factor, they will all have equal angles.</p>

  <p>What if we wanted one sector to be twice as large as the other? To do that, we could calculate their angles manually and set them as static values. An easier way would be to make use of dynamic values.</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(100, [
        RM.sector("Sector 1", d(2), {fill: "lightblue"}),
        RM.sector("Sector 2", d(1), {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>Sector offsets can be dynamic as well.</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(150, [
        RM.sector("Sector 1", d(2), d(1), {fill: "lightblue"}),
        RM.sector("Sector 2", d(1), d(2), {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>Sector 1 is twice as big as sector 2, while the space from sector 1 to sector 2 is twice as small as the space from sector 2 to sector 1. Sectors or offsets of the same dynamic factor will have the same angle.</p>

  <p>For convenience, <code>RingMenu</code> also provides a <code>dsector</code> shortcut for creating a sector where the provided angle and offset are dynamic values by default. You can't provide static values to a <code>dsector</code>. Here's the same example as the previous exaple using <code>dsector</code>:</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(150, [
        RM.dsector("Sector 1", 2, 1, {fill: "lightblue"}),
        RM.dsector("Sector 2", 1, 2, {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>A ring offset can also be a dynamic value.</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.ring(150, 0, d(0.5), [
        RM.sector("Sector 1", {fill: "lightblue"}),
        RM.sector("Sector 2", {fill: "lightgreen"}),
        RM.sector("Sector 3", {fill: "lightblue"}),
        RM.sector("Sector 4", {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  {{ heading('h2', 'Mixing dynamic and static values') }}

  <p>Let's say you wanted a ring of sectors with fixed angles, but you also wanted to make sure that the space between each sector is equal. It's easy with dynamic values:</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.gap(50),
      RM.ring(100, d(1), [
        RM.sector("40", 40, {fill: "lightblue"}),
        RM.sector("80", 80, {fill: "lightgreen"}),
        RM.sector("20", 20, {fill: "lightblue"}),
        RM.sector("100", 100, {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>Remember that dynamic values represent parts of a whole. This whole is the entire 360 degrees minus any static angles or offsets your sector might have. If you were to calculate the offsets manually, you'd first have to calculate the whole and divide it by the number of sectors. Using dynamic values does all of that for you under the hood.</p>

  <p>We could just as easily do the opposite; make a ring where the offsets between sectors are static,while the sectors themselves are dynamic:</p>

  {{ example('
    const d = RM.dynamic;

    const menu = RM.menu([
      RM.gap(50),
      RM.ring(100, 30, [
        RM.sector("1", {fill: "lightblue"}),
        RM.sector("2", {fill: "lightgreen"}),
        RM.sector("3", d(2), {fill: "lightblue"}),
        RM.sector("4", {fill: "lightgreen"}),
      ]),
    ]);
    const { el } = RM.build(menu);
  ')}}

  <p>We've ensured that the space between each sector is exactly 30 degrees, while also making sector 3 twice as large as the others.</p>
{% endblock %}